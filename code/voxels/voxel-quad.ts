// ********************************************************************************************************************
import { Scene } from 'three/src/Three';
// ********************************************************************************************************************
import { Vector3 } from '../types/vector3';
// ********************************************************************************************************************
import { VoxelArea } from './voxel-area';
// ********************************************************************************************************************
export class VoxelQuad extends VoxelArea {

    // ****************************************************************************************************************
    // dirty - whether dirty
    // ****************************************************************************************************************
    private dirty: boolean = false;

    // ****************************************************************************************************************
    // constructor
    // ****************************************************************************************************************
    constructor(private readonly scene: Scene, public readonly location: Vector3, min: Vector3, max: Vector3) { super(min, max); this.quad = this; }

    // ****************************************************************************************************************
    // function:    isDirty
    // ****************************************************************************************************************
    // parameters:  n/a
    // ****************************************************************************************************************
    // returns:     whether dirty
    // ****************************************************************************************************************
    public isDirty(): boolean {

        return this.dirty;
    }

    // ****************************************************************************************************************
    // function:    setDirty
    // ****************************************************************************************************************
    // parameters:  n/a
    // ****************************************************************************************************************
    // returns:     n/a
    // ****************************************************************************************************************
    public setDirty(): void {

        this.dirty = true;
    }







/*
    // ****************************************************************************************************************
    // noise - the noise
    // ****************************************************************************************************************
    private static noise: NoiseFunction2D = createNoise2D();

    // ****************************************************************************************************************
    // dirty - whether dirty
    // ****************************************************************************************************************
    public dirty: boolean = true;

    // ****************************************************************************************************************
    // geometry - the geometry
    // ****************************************************************************************************************
    private geometry: BufferGeometry | null = null;

    // ****************************************************************************************************************
    // material - the material
    // ****************************************************************************************************************
    private material: Material = new MeshStandardMaterial({ color: '#ffffff', wireframe: false });

    // ****************************************************************************************************************
    // mesh - the mesh
    // ****************************************************************************************************************
    private mesh: InstancedMesh | null = null;

    // ****************************************************************************************************************
    // size - the size
    // ****************************************************************************************************************
    public readonly size: number = 0;

    // ****************************************************************************************************************
    // voxels - the voxels
    // ****************************************************************************************************************
    private voxels: number[][][] = [];



    // ****************************************************************************************************************
    // function:    createArray
    // ****************************************************************************************************************
    // parameters:  n/a
    // ****************************************************************************************************************
    // returns:     n/a
    // ****************************************************************************************************************
    private createArray(): void {

        for (var x = 0; x < this.size; x++) {

            this.voxels[x] = [];

            for (var y = 0; y < this.size; y++) {

                this.voxels[x][y] = [];

                for (var z = 0; z < this.size; z++) {

                    this.voxels[x][y][z] = 0;
                }
            }
        }
    }

    // ****************************************************************************************************************
    // function:    getVoxel
    // ****************************************************************************************************************
    // parameters:  position - the position
    // ****************************************************************************************************************
    // returns:     the voxel
    // ****************************************************************************************************************
    public getVoxel(position: Vector3): number {

        if (this.insideOrOnEdge(position)) {

            const x = position.x - this.min.x;

            const y = position.y - this.min.y;

            const z = position.z - this.min.z;

            return this.voxels[x][y][z];
        }
        return 0;
    }

    // ****************************************************************************************************************
    // function:    setVoxel
    // ****************************************************************************************************************
    // parameters:  position - the position
    // ****************************************************************************************************************
    //              voxel - the voxel
    // ****************************************************************************************************************
    // returns:     n/a
    // ****************************************************************************************************************
    public setVoxel(position: Vector3, voxel: number): void {

        if (this.insideOrOnEdge(position)) {

            const x = position.x - this.min.x;

            const y = position.y - this.min.y;

            const z = position.z - this.min.z;

            this.voxels[x][y][z] = voxel;

            this.dirty = true;
        }
    }

    // ****************************************************************************************************************
    // function:    setVoxels
    // ****************************************************************************************************************
    // parameters:  bounds - the bounds
    // ****************************************************************************************************************
    //              voxel - the voxel
    // ****************************************************************************************************************
    // returns:     n/a
    // ****************************************************************************************************************
    public setVoxels(bounds: Bounds3, voxel: number): void {

        if (this.intersects(bounds)) {

            for (var x = bounds.min.x; x < bounds.max.x; x++) {

                for (var y = bounds.min.y; y < bounds.max.y; y++) {

                    for (var z = bounds.min.z; z < bounds.max.z; z++) {

                        this.setVoxel(new Vector3(x, y, z), voxel);
                    }
                }
            }
        }
    }

    // ****************************************************************************************************************
    // function:    updateGeometry
    // ****************************************************************************************************************
    // parameters:  n/a
    // ****************************************************************************************************************
    // returns:     n/a
    // ****************************************************************************************************************
    public updateGeometry(): void {

        if (!this.dirty) return;

        // ************************************************************************************************************
        // update geometry
        // ************************************************************************************************************

        this.geometry = this.geometry ?? new BoxGeometry(1, 1, 1, 1, 1, 1);

        const matrices: Matrix4[] = [];

        for (var x = 0; x < this.size; x++) {

            for (var y = 0; y < this.size; y++) {

                for (var z = 0; z < this.size; z++) {

                    const voxel = this.voxels[x][y][z];

                    const voxelMinX = x > 0 ? this.voxels[x - 1][y][z] : null;

                    const voxelMaxX = x < this.size - 1 ? this.voxels[x + 1][y][z] : null;

                    const voxelMinY = y > 0 ? this.voxels[x][y - 1][z] : null;

                    const voxelMaxY = y < this.size - 1 ? this.voxels[x][y + 1][z] : null;

                    const voxelMinZ = z > 0 ? this.voxels[x][y][z - 1] : null;

                    const voxelMaxZ = z < this.size - 1 ? this.voxels[x][y][z + 1] : null;

                    if (voxel > 0 && (voxelMinX === null || voxelMaxX === null || voxelMinY === null || voxelMaxY === null || voxelMinZ === null || voxelMaxZ === null)) {

                        const matrix = new Matrix4();

                        matrix.setPosition(this.min.x + x, this.min.y + y, this.min.z + z);

                        matrices.push(matrix);
                    }
                }
            }
        }

        // ************************************************************************************************************
        // update mesh
        // ************************************************************************************************************

        if (this.mesh) this.scene.remove(this.mesh);

        this.mesh = new InstancedMesh(this.geometry, this.material, matrices.length);

        for (var i = 0; i < matrices.length; i++) {

            this.mesh.setMatrixAt(i, matrices[i]);
        }
        this.scene.add(this.mesh);

        this.dirty = false;
    }
    */
}
